// Package calldepth does black-box testing.
//
// Another intentional effect is that "go test" compiles
// this into a separate binary which we need because
// we have to configure klog differently that TestOutput.

package calldepth

import (
	"flag"
	"fmt"
	"runtime"
	"strings"
	"testing"

	"github.com/go-logr/logr"
	"k8s.io/klog/v2"
)

func TestCallDepth(t *testing.T) {
	var l tlogger

	klog.InitFlags(nil)
	flag.CommandLine.Set("v", "10")
	flag.Parse()

	init := func() {
		callers := ""
		l = tlogger{callers: &callers}
		klog.SetLogger(l)
	}

	haveExpectedSource := func(t *testing.T, expectedSource string) {
		t.Helper()
		if !strings.Contains(*l.callers, expectedSource+":") {
			t.Fatalf("output should have contained %s, got instead: %s", expectedSource, *l.callers)
		}

	}

	validate := func(t *testing.T) {
		t.Helper()
		haveExpectedSource(t, "call_depth_main_test.go")
	}

	t.Run("tlogger.Info", func(t *testing.T) {
		init()
		l.Info("hello world")
		validate(t)
	})

	t.Run("Error", func(t *testing.T) {
		init()
		klog.Error("hello world")
		validate(t)
	})

	t.Run("ErrorS", func(t *testing.T) {
		init()
		klog.ErrorS(nil, "hello world")
		validate(t)
	})

	t.Run("ErrorSDepth", func(t *testing.T) {
		init()
		klog.ErrorS(nil, "hello world")
		validate(t)
	})

	t.Run("Errorf", func(t *testing.T) {
		init()
		klog.Errorf("hello world")
		validate(t)
	})

	t.Run("Errorln", func(t *testing.T) {
		init()
		klog.Errorln("hello world")
		validate(t)
	})

	/* Not tested:
	func Exit(args ...interface{})
	func ExitDepth(depth int, args ...interface{})
	func Exitf(format string, args ...interface{})
	func Exitln(args ...interface{})
	func Fatal(args ...interface{})
	func FatalDepth(depth int, args ...interface{})
	func Fatalf(format string, args ...interface{})
	func Fatalln(args ...interface{})
	*/

	t.Run("Info", func(t *testing.T) {
		init()
		klog.Info("hello world")
		validate(t)
	})

	t.Run("InfoDepth", func(t *testing.T) {
		init()
		klog.InfoDepth(0, "hello world")
		validate(t)
	})

	t.Run("InfoS", func(t *testing.T) {
		init()
		klog.InfoS("hello world")
		validate(t)
	})

	t.Run("InfoSDepth", func(t *testing.T) {
		init()
		klog.InfoSDepth(0, "hello world")
		validate(t)
	})

	t.Run("Infof", func(t *testing.T) {
		init()
		klog.Infof("hello world")
		validate(t)
	})

	t.Run("Infoln", func(t *testing.T) {
		init()
		klog.Infoln("hello world")
		validate(t)
	})

	t.Run("Warning", func(t *testing.T) {
		init()
		klog.Warning("hello world")
		validate(t)
	})

	t.Run("WarningDepth", func(t *testing.T) {
		init()
		klog.WarningDepth(0, "hello world")
		validate(t)
	})

	t.Run("Warningf", func(t *testing.T) {
		init()
		klog.Warningf("hello world")
		validate(t)
	})

	t.Run("Warningln", func(t *testing.T) {
		init()
		klog.Warningln("hello world")
		validate(t)
	})

	t.Run("V.Error", func(t *testing.T) {
		init()
		klog.V(1).Error(nil, "hello world")
		validate(t)
	})

	t.Run("V.ErrorS", func(t *testing.T) {
		init()
		klog.V(1).ErrorS(nil, "hello world")
		validate(t)
	})

	t.Run("V.Info", func(t *testing.T) {
		init()
		klog.V(1).Info("hello world")
		validate(t)
	})

	t.Run("InfoS", func(t *testing.T) {
		init()
		klog.V(1).InfoS("hello world")
		validate(t)
	})

	t.Run("V.Infoln", func(t *testing.T) {
		init()
		klog.V(1).Infoln("hello world")
		validate(t)
	})

	t.Run("helper", func(t *testing.T) {
		init()
		// Normally, myInfo logs its caller. With -1 as depth
		// we get it to log its own source code.
		myInfo(-1, "hello world")
		haveExpectedSource(t, "call_depth_helper_test.go")
	})

	t.Run("indirect", func(t *testing.T) {
		init()
		myInfo(0, "hello world")
		validate(t)
	})

	t.Run("nested", func(t *testing.T) {
		init()
		myInfo2("hello world")
		validate(t)
	})
}

// tlogger is a partial logr implementation: it only captures the caller source code location
// in a string and ignores the actual message.
type tlogger struct {
	callDepth int
	callers   *string
}

// Magic string for intermediate frames that we should ignore.
const autogeneratedFrameName = "<autogenerated>"

// Discover how many frames we need to climb to find the caller. This approach
// was suggested by Ian Lance Taylor of the Go team, so it *should* be safe
// enough (famous last words).
//
// It is needed because binding the specific klogger functions to the
// logr interface creates one additional call frame that neither we nor
// our caller know about.
func framesToCaller() int {
	// 1 is the immediate caller.  3 should be too many.
	for i := 1; i < 3; i++ {
		_, file, _, _ := runtime.Caller(i + 1) // +1 for this function's frame
		if file != autogeneratedFrameName {
			return i
		}
	}
	return 1 // something went wrong, this is safe
}

func (l tlogger) print(depth int) {
	_, file, line, _ := runtime.Caller(depth)
	*l.callers += fmt.Sprintf("%s:%d\n", file, line)
}

func (l tlogger) Info(msg string, kvList ...interface{}) {
	l.print(l.callDepth + 1 + framesToCaller())
}

func (l tlogger) Enabled() bool {
	return true
}

func (l tlogger) Error(err error, msg string, kvList ...interface{}) {
	l.print(l.callDepth + 1 + framesToCaller())
}

func (l tlogger) V(level int) logr.Logger {
	return l
}

func (l tlogger) WithName(name string) logr.Logger {
	return l
}

func (l tlogger) WithValues(kvList ...interface{}) logr.Logger {
	return l
}

func (l tlogger) WithCallDepth(depth int) logr.Logger {
	new := l
	new.callDepth += depth
	return new
}

var _ logr.Logger = tlogger{}
